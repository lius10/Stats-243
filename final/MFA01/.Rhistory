}
# eigenvalue and inertia
eigen <- sgl^2
newList <- list(eigen,cfs,fl)
return(newList)
}
# private function to get particial factor scores,input should include both assessor and factor loading
PFS <- function(a,idx,w,fl){
pfl <- list()
pfs <- list()
for(i in 1:length(a)){
pfl[[i]] <- split(data.frame(fl),idx)[[i]]  #subset by row
pfs[[i]] <- length(a)* w[i]* as.matrix(a[[i]]) %*% as.matrix(pfl[[i]])
}
newList <- list(pfl,pfs)
return(newList)
}
#' @export
print.mfa <- function(x, ...) {
cat('object "mfa"\n\n')
cat("Number of tables/blocks for analysis:", length(x$assessors),"\n")
cat("Weight of tables:", "\n",unique(x$weights), "\n")
cat("First two eigenvalues: ", x$eigen[1:2], "\n")
cat("First component of common factor scores: ","\n",x$cfs[,1], "\n")
cat("Facor loadings for the first table (1st component): ", "\n",
x$pfl[1:length(x$assessors[[1]]),1], "\n")
# cat("Partial factor score for the first table (1st component): ", x$pfs[[1]], "\n")
invisible(x)
}
a<-MFA()
# private function to subset data (by column)
subset_data <- function(d, s) {
a <- list()
j <- list()
for(i in 1:length(s)){
a[[i]] <- d[,s[[i]]]
j[[i]] <- length(a[[i]])
}
newList <- list(a,j)
return(newList)
}
a<-MFA()
source('R/other-mfa-methods.R')
ctr.var(a)
x<-print(1)
x
a.pfl
a$pfl
length(a$pfl)
a$pfl[[i]]
a$pfl[[1]]
sum(a$pfl[[1]])
ttt <- list()
for(i in length(a$pfl)){
ttt[[i]] <- a$pfl[[i]]
}
ttt
a$pfl
a$fl
a$fl
MFA <- function(data = get(load("data/wine.rda")),
sets =list(2:7,8:13,14:19,20:24,25:30,31:35,36:39,40:45,46:50,51:54),
ncomps = NULL, center=TRUE,scale=TRUE) {
# check whether each table is numeric
data <- scale_data(d = data,s= sets,ctr = center, sc=scale)
# check ncomps
check_n(n = ncomps)
# subset data
aj <- subset_data(d = data, s = sets)
assessor <- aj [[1]] ; j <- aj[[2]] # a : assessor ; j: length of each element in a
index_list <- rep(1:length(j),times=j)
#SVD
weight <- SVD(a=assessor)
#GSVD - return list(eigen,cfs,fl)
gsvd <- GSVD(d=data,s=sets,w=weight,n=ncomps)
# return list(pfl, pfs)
pf <- PFS(a= assessor ,idx = index_list,w= weight,fl = gsvd[[3]])
object <- list(
assessors = assessor,
index_lists = index_list,
weights = weight,
eigen= gsvd[[1]], # vector
cfs = gsvd[[2]], # matrix
fl = gsvd[[3]], # matrix
pfl = pf[[1]],
pfs = pf[[2]])  # list
class(object) <- "mfa"
object
}
ttt <- split(a$fl,a$index_lists)
a$index_lists
a<-MFA()
a$index_lists
ttt <- split(a$fl,a$index_lists)
ttt
a$pfl
a$fl
ttt
dim(a$fl)
?split
ttt <- split(data.frame(a$fl),a$index_lists)
ttt
ttt[[1]]
apply(ttt[[1]], 2,sum)
source('R/other-mfa-methods.R')
ctr.var(a)
ctr.table(a)
t <- ctr.var(a)
ctr.slt <- split(data.frame(t),a$index_lists)
ctr.slt
ctr.table <- list()
for (i in length(ctr.slt)){
ctr.table[[i]]  <- apply(ctr.slt[[1]], 2,sum)
}
ctr.table
ctr.table <- list()
for (i in length(ctr.slt)){
ctr.table[[i]]  <- apply(ctr.slt[[i]], 2,sum)
}
ctr.table
ctr.slt[[1]]
ctr.slt[[2]]
apply(ctr.slt[[1]], 2,sum)
ctr.table <- list()
for (i in length(ctr.slt)){
ctr.table[[i]]  <- apply(ctr.slt[[i]], 2,sum)
}
ctr.table
ctr.table <- list()
for (i in 1:length(ctr.slt)){
ctr.table[[i]]  <- apply(ctr.slt[[i]], 2,sum)
}
ctr.table
source('R/other-mfa-methods.R')
ctr.table(a)
source('R/other-mfa-methods.R')
ctr.table(a)
source('R/other-mfa-methods.R')
ctr.table(a)
source('R/other-mfa-methods.R')
x <- ctr.table(a)
x
x <- ctr.table(a)
x
x <- ctr.var(a)
x
x <- ctr.obs(a)
x
source('R/other-mfa-methods.R')
x <- ctr.obs(a)
source('R/other-mfa-methods.R')
x <- ctr.obs(a)
x
sum(x[,1])
x <- ctr.var(a)
x
sum(x[,1])
x <- ctr.table(a)
x
sum(x[[1]])
sum(x)
x <- ctr.table(a,table = 1)
x <- ctr.table(a,table = 1)
x <- ctr.table(a,table = 1)
x
table <- NULL
is.null(table)
!is.null(table)
x <- ctr.table(a,table = 1)
x <- ctr.table(a,table = 1,comp=2)
ctr.var(a,var=NULL,comp=1)
source('R/other-mfa-methods.R')
ctr.var(a,var=NULL,comp=1)
ctr.obs(a,obs=NULL,comp=1)
ctr.obs(a)
ctr.obs(a,obs=NULL,comp=1)
ctr.var(a,var=NULL,comp=1)
ctr.var(a,var=NULL,comp=1)
ctr.var(a)
ctr.table(a,table = 1,comp=2)
ctr.table(a)
a<-MFA()
library(devtools)
# creating documentation (i.e. the Rd files in man/)
devtools::document()
# checking documentation
devtools::check_man()
# building tarball (e.g. oski_0.1.tar.gz)
devtools::build()
# checking install
devtools::install()
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
library(devtools)
# creating documentation (i.e. the Rd files in man/)
devtools::document()
# checking documentation
devtools::check_man()
# building tarball (e.g. oski_0.1.tar.gz)
devtools::build()
# checking install
devtools::install()
install.packages('MGA01')
install.packages('MGA01')
library(MGA01)
devtools::document()
# checking documentation
devtools::check_man()
# building tarball (e.g. oski_0.1.tar.gz)
devtools::build()
# checking install
devtools::install()
install.packages('C:/Users/Emma/Downloads/stats-243/final/MFA01_0.1.0.tar.gz')
pkg <- 'MFA01'
devtools::document(pkg = pkg)
devtools::check_man(pkg = pkg)
devtools::test(pkg = pkg)
devtools::build_vignettes(pkg = pkg)
devtools::build(pkg = pkg)
devtools::install(pkg = pkg)
setwd('C:/Users/Emma/Downloads/stats-243/final/MFA01')
library(devtools)
pkg <- 'MFA01'
devtools::document(pkg = pkg)
devtools::check_man(pkg = pkg)
devtools::test(pkg = pkg)
devtools::build_vignettes(pkg = pkg)
devtools::build(pkg = pkg)
devtools::install(pkg = pkg)
setwd('C:/Users/Emma/Downloads/stats-243/final/')
library(devtools)
pkg <- 'MFA01'
devtools::document(pkg = pkg)
devtools::check_man(pkg = pkg)
devtools::test(pkg = pkg)
library(MFA01)
source('R/other-mfa-methods.R')
a <- MFA()
MFA <- function(data = get(load("data/wine.rda")),
sets =list(2:7,8:13,14:19,20:24,25:30,31:35,36:39,40:45,46:50,51:54),
ncomps = NULL, center=TRUE,scale=TRUE) {
# check whether each table is numeric
data <- scale_data(d = data,s= sets,ctr = center, sc=scale)
# check ncomps
check_n(n = ncomps)
# subset data
aj <- subset_data(d = data, s = sets)
assessor <- aj [[1]] ; j <- aj[[2]] # a : assessor ; j: length of each element in a
index_list <- rep(1:length(j),times=j)
#SVD
weight <- SVD(a=assessor)
#GSVD - return list(eigen,cfs,fl)
gsvd <- GSVD(d=data,s=sets,w=weight,n=ncomps)
# return list(pfl, pfs)
pf <- PFS(a= assessor ,idx = index_list,w= weight,fl = gsvd[[3]])
object <- list(
assessors = assessor,
index_lists = index_list,
weights = weight,
eigen= gsvd[[1]], # vector
cfs = gsvd[[2]], # matrix
fl = gsvd[[3]], # matrix
pfl = pf[[1]],
pfs = pf[[2]])  # list
class(object) <- "mfa"
object
}
# private function to scale data
scale_data <- function(d,s,ctr=TRUE,sc=TRUE) {
t <- try(scale(d[unlist(s)]),silent = T)
if("try-error" %in% class(t)) {
stop("\neach table/block must be numeric")
}
# sum of the square values of all its elements is equal to 1
d[unlist(s)] <- scale(d[unlist(s)],center = ctr, scale = sc)/((nrow(d)-1)^0.5)
return(d)
}
# private function to check number of components
check_n <- function(n){
if (!is.null(n)){
if (n <= 0 | !is.numeric(n)) {
stop("\nargument 'ncomps' must be a positive integer")
}
} else {
TRUE
}
}
# private function to subset data (by column)
subset_data <- function(d, s) {
a <- list()
j <- list()
for(i in 1:length(s)){
a[[i]] <- d[,s[[i]]]
j[[i]] <- length(a[[i]])
}
newList <- list(a,j)
return(newList)
}
# private function to get SVD, input should be assessor (list)
SVD <- function(a){
svd_data <- list()
weight <- c()
# sgl <- list()
# fs <- list()
for(i in 1:length(a)){
svd_data[[i]] <- svd(a[[i]])
# sgl[[i]] <- diag(svd[[i]]$d,length(svd[[i]]$d),length(svd[[i]]$d))
# fs[[i]] <-  ((-1) * svd[[i]]$u) %*% sgl[[i]]
weight <- c(weight,rep(1/svd_data[[i]]$d[1]^2,ncol(a[[i]])))
}
return(weight)
}
# private function to get GSVD, input should be whole data
GSVD <- function(d,s,w,n=2){
# get constrains
d <- as.matrix(d[unlist(s)])
len <- nrow(d)
m <-  diag(1/len,len,len)
m_0.5 <- diag((1/len)^(-0.5),len,len)
weight.mx <- diag(w,length(w),length(w))
weight_0.5.mx <-  diag(w^(-0.5),length(w),length(w))
# GSVD matrix
y <- sqrt(m) %*% d %*%sqrt(weight.mx)
GSVD <- svd(y)
if(is.null(n)){
left <- m_0.5 %*% GSVD$u
sgl <- GSVD$d
#loading - table 3 loadings (Q)
fl <- weight_0.5.mx %*% GSVD$v
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,ncol(GSVD$u),ncol(GSVD$u))
} else {
left <- m_0.5 %*% GSVD$u[,1:n]
sgl <- GSVD$d[1:n]
fl <- weight_0.5.mx %*% GSVD$v[,1:n]
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,n,n)
}
# eigenvalue and inertia
eigen <- sgl^2
newList <- list(eigen,cfs,fl)
return(newList)
}
# private function to get particial factor scores,input should include both assessor and factor loading
PFS <- function(a,idx,w,fl){
pfl <- list()
pfs <- list()
for(i in 1:length(a)){
pfl[[i]] <- split(data.frame(fl),idx)[[i]]  #subset by row
pfs[[i]] <- length(a)* w[i]* as.matrix(a[[i]]) %*% as.matrix(pfl[[i]])
}
newList <- list(pfl,pfs)
return(newList)
}
#' @export
print.mfa <- function(x, ...) {
cat('object "mfa"\n\n')
cat("Number of tables/blocks for analysis:", length(x$assessors),"\n")
cat("Weight of tables:", "\n",unique(x$weights), "\n")
cat("First two eigenvalues: ", x$eigen[1:2], "\n")
cat("First component of common factor scores: ","\n",x$cfs[,1], "\n")
cat("Facor loadings for the first table (1st component): ", "\n",
x$pfl[1:length(x$assessors[[1]]),1], "\n")
# cat("Partial factor score for the first table (1st component): ", x$pfs[[1]], "\n")
invisible(x)
}
a <- MFA()
MFA <- function(data = get(load("data/wine.rda")),
sets =list(2:7,8:13,14:19,20:24,25:30,31:35,36:39,40:45,46:50,51:54),
ncomps = NULL, center=TRUE,scale=TRUE) {
# check whether each table is numeric
data <- scale_data(d = data,s= sets,ctr = center, sc=scale)
# check ncomps
check_n(n = ncomps)
# subset data
aj <- subset_data(d = data, s = sets)
assessor <- aj [[1]] ; j <- aj[[2]] # a : assessor ; j: length of each element in a
index_list <- rep(1:length(j),times=j)
#SVD
weight <- SVD(a=assessor)
#GSVD - return list(eigen,cfs,fl)
gsvd <- GSVD(d=data,s=sets,w=weight,n=ncomps)
# return list(pfl, pfs)
pf <- PFS(a= assessor ,idx = index_list,w= weight,fl = gsvd[[3]])
object <- list(
assessors = assessor,
index_lists = index_list,
weights = weight,
eigen= gsvd[[1]], # vector
cfs = gsvd[[2]], # matrix
fl = gsvd[[3]], # matrix
pfl = pf[[1]],
pfs = pf[[2]])  # list
class(object) <- "mfa"
object
}
# private function to scale data
scale_data <- function(d,s,ctr=TRUE,sc=TRUE) {
t <- try(scale(d[unlist(s)]),silent = T)
if("try-error" %in% class(t)) {
stop("\neach table/block must be numeric")
}
# sum of the square values of all its elements is equal to 1
d[unlist(s)] <- scale(d[unlist(s)],center = ctr, scale = sc)/((nrow(d)-1)^0.5)
return(d)
}
# private function to check number of components
check_n <- function(n){
if (!is.null(n)){
if (n <= 0 | !is.numeric(n)) {
stop("\nargument 'ncomps' must be a positive integer")
}
} else {
TRUE
}
}
# private function to subset data (by column)
subset_data <- function(d, s) {
a <- list()
j <- list()
for(i in 1:length(s)){
a[[i]] <- d[,s[[i]]]
j[[i]] <- length(a[[i]])
}
newList <- list(a,j)
return(newList)
}
# private function to get SVD, input should be assessor (list)
SVD <- function(a){
svd_data <- list()
weight <- c()
# sgl <- list()
# fs <- list()
for(i in 1:length(a)){
svd_data[[i]] <- svd(a[[i]])
# sgl[[i]] <- diag(svd[[i]]$d,length(svd[[i]]$d),length(svd[[i]]$d))
# fs[[i]] <-  ((-1) * svd[[i]]$u) %*% sgl[[i]]
weight <- c(weight,rep(1/svd_data[[i]]$d[1]^2,ncol(a[[i]])))
}
return(weight)
}
# private function to get GSVD, input should be whole data
GSVD <- function(d,s,w,n=2){
# get constrains
d <- as.matrix(d[unlist(s)])
len <- nrow(d)
m <-  diag(1/len,len,len)
m_0.5 <- diag((1/len)^(-0.5),len,len)
weight.mx <- diag(w,length(w),length(w))
weight_0.5.mx <-  diag(w^(-0.5),length(w),length(w))
# GSVD matrix
y <- sqrt(m) %*% d %*%sqrt(weight.mx)
GSVD <- svd(y)
if(is.null(n)){
left <- m_0.5 %*% GSVD$u
sgl <- GSVD$d
#loading - table 3 loadings (Q)
fl <- weight_0.5.mx %*% GSVD$v
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,ncol(GSVD$u),ncol(GSVD$u))
} else {
left <- m_0.5 %*% GSVD$u[,1:n]
sgl <- GSVD$d[1:n]
fl <- weight_0.5.mx %*% GSVD$v[,1:n]
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,n,n)
}
# eigenvalue and inertia
eigen <- sgl^2
newList <- list(eigen,cfs,fl)
return(newList)
}
# private function to get particial factor scores,input should include both assessor and factor loading
PFS <- function(a,idx,w,fl){
pfl <- list()
pfs <- list()
for(i in 1:length(a)){
pfl[[i]] <- split(data.frame(fl),idx)[[i]]  #subset by row
pfs[[i]] <- length(a)* w[i]* as.matrix(a[[i]]) %*% as.matrix(pfl[[i]])
}
newList <- list(pfl,pfs)
return(newList)
}
#' @export
print.mfa <- function(x, ...) {
cat('object "mfa"\n\n')
cat("Number of tables/blocks for analysis:", length(x$assessors),"\n")
cat("Weight of tables:", "\n",unique(x$weights), "\n")
cat("First two eigenvalues: ", x$eigen[1:2], "\n")
cat("First component of common factor scores: ","\n",x$cfs[,1], "\n")
cat("Facor loadings for the first table (1st component): ", "\n",
x$pfl[1:length(x$assessors[[1]]),1], "\n")
# cat("Partial factor score for the first table (1st component): ", x$pfs[[1]], "\n")
invisible(x)
}
source('R/other-mfa-methods.R')
a <- MFA()
getwd()
ctr.obs(a)
ctr.obs(a,obs = 1)
ctr.obs.mfa(a,obs = 1)
source('R/other-mfa-methods.R')
ctr.obs(a,obs=1)
setwd('C:/Users/Emma/Downloads/stats-243/final/')
library(devtools)
pkg <- 'MFA01'
devtools::document(pkg = pkg)
devtools::check_man(pkg = pkg)
devtools::test(pkg = pkg)
library(MFA01)
a <- MFA()
a <- MFA()
a

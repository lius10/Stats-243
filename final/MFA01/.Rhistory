devtools::install()
library(devtools)
# creating documentation (i.e. the Rd files in man/)
devtools::document()
# checking documentation
devtools::check_man()
# building tarball (e.g. oski_0.1.tar.gz)
devtools::build()
# checking install
devtools::install()
#' @title Multiple Factor Analysis
#' @description Creates an object of class \code{"mfa"}
#' @param data data set (matrix or data frame)
#' @param sets list of vector indicating the sets of variables (i.e. the blocks)
#' @param ncomps integer indicating how many number of components (i.e. factors) are to be extracted
#' @param center either a logical value or a numeric vector of length equal to the number of active variables in the analysis
#' @param scale either a logical value or a numeric vector of length equal to the number of active variables in the analysis
#' @return an object of class \code{"mfa"} with the following elements:
#' @return \item{eigen}{vector of eigenvalues}
#' @return \item{cfs}{matrix of common factor scores}
#' @return \item{fl}{matrix of loadings (a.k.a. factor loadings)}
#' @return \item{pfs}{matrix of partial factors scores}
#' @export
#' @examples
#' # default
#' mfa1 <- MFA()
#'
#' # another mfa
#' mfa2 <- MFA(ncomps=2)
#'
MFA <- function(data = get(load("data/wine.rda")),
sets =list(2:7,8:13,14:19,20:24,25:30,31:35,36:39,40:45,46:50,51:54),
ncomps = NULL, center=TRUE,scale=TRUE) {
# check whether each table is numeric
data <- scale_data(d = data,s= sets,ctr = center, sc=scale)
# check ncomps
check_n(n = ncomps)
# subset data
aj <- subset_data(d = data, s = sets)
assessor <- aj [[1]] ; j <- aj[[2]] # a : assessor ; j: length of each element in a
index_list <- rep(1:length(j),times=j)
#SVD
weight <- SVD(a=assessor)
#GSVD - return list(eigen,cfs,fl)
gsvd <- GSVD(d=data,s=sets,w=weight,n=ncomps)
# return list(pfl, pfs)
pf <- PFS(a= assessor ,idx = index_list,w= weight,fl = gsvd[[3]])
object <- list(
assessors = assessor,
index_lists = index_list,
weights = weight,
eigen= gsvd[[1]], # vector
cfs = gsvd[[2]], # matrix
fl = gsvd[[3]], # matrix
pfl = pf[[1]],
pfs = pf[[2]])  # list
class(object) <- "mfa"
object
}
# private function to scale data
scale_data <- function(d,s,ctr=TRUE,sc=TRUE) {
t <- try(scale(d[unlist(s)]),silent = T)
if("try-error" %in% class(t)) {
stop("\neach table/block must be numeric")
}
# sum of the square values of all its elements is equal to 1
d[unlist(s)] <- scale(d[unlist(s)],center = ctr, scale = sc)/((nrow(d)-1)^0.5)
return(d)
}
# private function to check number of components
check_n <- function(n){
if (!is.null(n)){
if (n <= 0 | !is.numeric(n)) {
stop("\nargument 'ncomps' must be a positive integer")
}
} else {
TRUE
}
}
# private function to subset data (by column)
subset_data <- function(d, s) {
a <- list()
j <- list()
for(i in 1:length(s)){
a[[i]] <- d[,s[[i]]]
j[[i]] <- length(a[[i]])
}
newList <- list(a,j)
return(newList)
}
# private function to get SVD, input should be assessor (list)
SVD <- function(a){
svd_data <- list()
weight <- c()
# sgl <- list()
# fs <- list()
for(i in 1:length(a)){
svd_data[[i]] <- svd(a[[i]])
# sgl[[i]] <- diag(svd[[i]]$d,length(svd[[i]]$d),length(svd[[i]]$d))
# fs[[i]] <-  ((-1) * svd[[i]]$u) %*% sgl[[i]]
weight <- c(weight,rep(1/svd_data[[i]]$d[1]^2,ncol(a[[i]])))
}
return(weight)
}
# private function to get GSVD, input should be whole data
GSVD <- function(d,s,w,n=2){
# get constrains
d <- as.matrix(d[unlist(s)])
len <- nrow(d)
m <-  diag(1/len,len,len)
m_0.5 <- diag((1/len)^(-0.5),len,len)
weight.mx <- diag(w,length(w),length(w))
weight_0.5.mx <-  diag(w^(-0.5),length(w),length(w))
# GSVD matrix
y <- sqrt(m) %*% d %*%sqrt(weight.mx)
GSVD <- svd(y)
if(is.null(n)){
left <- m_0.5 %*% GSVD$u
sgl <- GSVD$d
#loading - table 3 loadings (Q)
fl <- weight_0.5.mx %*% GSVD$v
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,ncol(GSVD$u),ncol(GSVD$u))
} else {
left <- m_0.5 %*% GSVD$u[,1:n]
sgl <- GSVD$d[1:n]
fl <- weight_0.5.mx %*% GSVD$v[,1:n]
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,n,n)
}
# eigenvalue and inertia
eigen <- sgl^2
newList <- list(eigen,cfs,fl)
return(newList)
}
# private function to get particial factor scores,input should include both assessor and factor loading
PFS <- function(a,idx,w,fl){
pfl <- list()
pfs <- list()
for(i in 1:length(a)){
pfl[[i]] <- split(data.frame(fl),idx)[[i]]  #subset by row
pfs[[i]] <- length(a)* w[i]* as.matrix(a[[i]]) %*% as.matrix(pfl[[i]])
}
newList <- list(pfl,pfs)
return(newList)
}
#' @export
print.mfa <- function(x, ...) {
cat('object "mfa"\n\n')
cat("Number of tables/blocks for analysis:", length(x$assessors),"\n")
cat("Weight of tables:", "\n",unique(x$weights), "\n")
cat("First two eigenvalues: ", x$eigen[1:2], "\n")
cat("First component of common factor scores: ","\n",x$cfs[,1], "\n")
cat("Facor loadings for the first table (1st component): ", "\n",
x$pfl[1:length(x$assessors[[1]]),1], "\n")
# cat("Partial factor score for the first table (1st component): ", x$pfs[[1]], "\n")
invisible(x)
}
#' @rdname mfa
#' @param x an R object
#' @export
is.mfa <- function(x) {
is(x, "mfa")
}
############### Below is function testing
# source('R/other-mfa-methods.R')
# a <- MFA()
MFA()
mfa1=MFA()
mfa1
mfa1$eigen
mfa1$pfs
rm(list=ls())
shiny::runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
#' @title Plot of object mfa
#' @description Plots the common factor scores and partial factor scores
#' @param x an object of class \code{"mfa"}
#' @param cfs whether to plot common factor scores
#' @param pfs whether to plot partial factor scores
#' @param pfl whether to plot factor loadings
#' @param num number of data table/block to plot
#' @param \dots arguments to be passed to/from other methods
#' @export
#' @examples
#'  \dontrun{
#'  # create a \code{"mfa"} and plot its common factor scores
#'  a <- MFA()
#'
#'  plot(a)
#'  }
#'
plot.mfa <- function(x, cfs = TRUE, pfs = FALSE, pfl = FALSE, num=1,...) {
plot(x$cfs[,1:2],xaxt="n", yaxt="n",
xlab="1st component",
ylab="2nd component",
bty="n",cex=1.5)
axis(side=1,pos = 0)
axis(side=2,pos = 0)
abline(v=0,h=0,col = "gray70", lwd = 1.5)
# text(GSVD.factor.score[,1],GSVD.factor.score[,2],labels = label ,cex=0.8,pos=3)
title(main="Common Facor scores")
legend("bottomright",pch = c(15, 16, 17),col = c("red", "green","blue"),
c("Canada","France","New Zealand"))
if(pfs && pfl){
pfs_scale <- rescale(x$pfs,sqrt(x$eigen))
loading_scale <- rescale(x$pfl,sqrt(x$eigen))
biplot(pfs_scale[[num]][,1:2],loading_scale[[num]][,1:2],xlab="1st component",ylab="2nd component")
abline(v=0,h=0)
title(main=paste("Partial Facor scores and variable loadings (No.", num," data table)"))
}
else if(pfs){
plot(x$pfs[[num]][,1:2],xaxt="n", yaxt="n",xlab="1st component",ylab="2nd component",
bty="n",cex=1.5)
axis(side=1,pos = 0)
axis(side=2,pos = 0)
abline(v=0,h=0)
# text(pfs[[num]][,1],pfs[[num]][,2],cex=0.8,pos=3)
title(main=paste("Partial facor scores (No.", num," data table)" ))
}
else if(pfl){
plot(x$pfl[[num]][,1:2],xaxt="n", yaxt="n",xlab="1st component",ylab="2nd component",
bty="n",cex=1.5)
axis(side=1,pos = 0)
axis(side=2,pos = 0)
abline(v=0,h=0)
# text(pl[[num]][,1],pl[[num]][,2],cex=0.8,pos=3)
title(main=paste("Variable loadings (No.", num," data table)" ))
}
}
# auxiliary functions for plot.mfa() method
# get scale factor for pfs and loadings so that their variance is equal to the singular value
scale_factor <- function(d,s){
f1 <- sqrt(apply(d, 2, var)[1]/s[1])
f2 <- sqrt(apply(d, 2, var)[2]/s[2])
scale_factors <- c(f1,f2)
return(scale_factors)
}
# rescale  pfs and loadings so that their variance is equal to the singular value
rescale <- function(d,s){
rescale <- list()
for(i in 1:length(d)){
rescale[[i]] <- scale(d[[i]][,1:2],center=FALSE,scale=scale_factor(d[[i]],s))}
return(rescale)
}
#' @title Multiple Factor Analysis
#' @description Creates an object of class \code{"mfa"}
#' @param data data set (matrix or data frame)
#' @param sets list of vector indicating the sets of variables (i.e. the blocks)
#' @param ncomps integer indicating how many number of components (i.e. factors) are to be extracted
#' @param center either a logical value or a numeric vector of length equal to the number of active variables in the analysis
#' @param scale either a logical value or a numeric vector of length equal to the number of active variables in the analysis
#' @return an object of class \code{"mfa"} with the following elements:
#' @return \item{eigen}{vector of eigenvalues}
#' @return \item{cfs}{matrix of common factor scores}
#' @return \item{fl}{matrix of loadings (a.k.a. factor loadings)}
#' @return \item{pfs}{matrix of partial factors scores}
#' @export
#' @examples
#' # default
#' mfa1 <- MFA()
#'
#' # another mfa
#' mfa2 <- MFA(ncomps=2)
#'
MFA <- function(data = get(load("data/wine.rda")),
sets =list(2:7,8:13,14:19,20:24,25:30,31:35,36:39,40:45,46:50,51:54),
ncomps = NULL, center=TRUE,scale=TRUE) {
# check whether each table is numeric
data <- scale_data(d = data,s= sets,ctr = center, sc=scale)
# check ncomps
check_n(n = ncomps)
# subset data
aj <- subset_data(d = data, s = sets)
assessor <- aj [[1]] ; j <- aj[[2]] # a : assessor ; j: length of each element in a
index_list <- rep(1:length(j),times=j)
#SVD
weight <- SVD(a=assessor)
#GSVD - return list(eigen,cfs,fl)
gsvd <- GSVD(d=data,s=sets,w=weight,n=ncomps)
# return list(pfl, pfs)
pf <- PFS(a= assessor ,idx = index_list,w= weight,fl = gsvd[[3]])
object <- list(
assessors = assessor,
index_lists = index_list,
weights = weight,
eigen= gsvd[[1]], # vector
cfs = gsvd[[2]], # matrix
fl = gsvd[[3]], # matrix
pfl = pf[[1]],
pfs = pf[[2]])  # list
class(object) <- "mfa"
object
}
# private function to scale data
scale_data <- function(d,s,ctr=TRUE,sc=TRUE) {
t <- try(scale(d[unlist(s)]),silent = T)
if("try-error" %in% class(t)) {
stop("\neach table/block must be numeric")
}
# sum of the square values of all its elements is equal to 1
d[unlist(s)] <- scale(d[unlist(s)],center = ctr, scale = sc)/((nrow(d)-1)^0.5)
return(d)
}
# private function to check number of components
check_n <- function(n){
if (!is.null(n)){
if (n <= 0 | !is.numeric(n)) {
stop("\nargument 'ncomps' must be a positive integer")
}
} else {
TRUE
}
}
# private function to subset data (by column)
subset_data <- function(d, s) {
a <- list()
j <- list()
for(i in 1:length(s)){
a[[i]] <- d[,s[[i]]]
j[[i]] <- length(a[[i]])
}
newList <- list(a,j)
return(newList)
}
# private function to get SVD, input should be assessor (list)
SVD <- function(a){
svd_data <- list()
weight <- c()
# sgl <- list()
# fs <- list()
for(i in 1:length(a)){
svd_data[[i]] <- svd(a[[i]])
# sgl[[i]] <- diag(svd[[i]]$d,length(svd[[i]]$d),length(svd[[i]]$d))
# fs[[i]] <-  ((-1) * svd[[i]]$u) %*% sgl[[i]]
weight <- c(weight,rep(1/svd_data[[i]]$d[1]^2,ncol(a[[i]])))
}
return(weight)
}
# private function to get GSVD, input should be whole data
GSVD <- function(d,s,w,n=2){
# get constrains
d <- as.matrix(d[unlist(s)])
len <- nrow(d)
m <-  diag(1/len,len,len)
m_0.5 <- diag((1/len)^(-0.5),len,len)
weight.mx <- diag(w,length(w),length(w))
weight_0.5.mx <-  diag(w^(-0.5),length(w),length(w))
# GSVD matrix
y <- sqrt(m) %*% d %*%sqrt(weight.mx)
GSVD <- svd(y)
if(is.null(n)){
left <- m_0.5 %*% GSVD$u
sgl <- GSVD$d
#loading - table 3 loadings (Q)
fl <- weight_0.5.mx %*% GSVD$v
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,ncol(GSVD$u),ncol(GSVD$u))
} else {
left <- m_0.5 %*% GSVD$u[,1:n]
sgl <- GSVD$d[1:n]
fl <- weight_0.5.mx %*% GSVD$v[,1:n]
# common factor scores - each row is a wine and each column is a component
cfs <- left %*% diag(sgl,n,n)
}
# eigenvalue and inertia
eigen <- sgl^2
newList <- list(eigen,cfs,fl)
return(newList)
}
# private function to get particial factor scores,input should include both assessor and factor loading
PFS <- function(a,idx,w,fl){
pfl <- list()
pfs <- list()
for(i in 1:length(a)){
pfl[[i]] <- split(data.frame(fl),idx)[[i]]  #subset by row
pfs[[i]] <- length(a)* w[i]* as.matrix(a[[i]]) %*% as.matrix(pfl[[i]])
}
newList <- list(pfl,pfs)
return(newList)
}
#' @export
print.mfa <- function(x, ...) {
cat('object "mfa"\n\n')
cat("Number of tables/blocks for analysis:", length(x$assessors),"\n")
cat("Weight of tables:", "\n",unique(x$weights), "\n")
cat("First two eigenvalues: ", x$eigen[1:2], "\n")
cat("First component of common factor scores: ","\n",x$cfs[,1], "\n")
cat("Facor loadings for the first table (1st component): ", "\n",
x$pfl[1:length(x$assessors[[1]]),1], "\n")
# cat("Partial factor score for the first table (1st component): ", x$pfs[[1]], "\n")
invisible(x)
}
#' @rdname mfa
#' @param x an R object
#' @export
is.mfa <- function(x) {
is(x, "mfa")
}
############### Below is function testing
# source('R/other-mfa-methods.R')
# a <- MFA()
a=MFA()
plot(a)
plot(a,cfs=FALSE,pfs=TRUE)
#' @title summary method
#' @description Summarizes information about the obtained eigenvalues
#' @param x an R object
#' @param digit number of decimal digit in print output
#' @export
ev.summary <- function(x) UseMethod("ev.summary")
#' @export
ev.summary.mfa <- function(x,digit=3, ...) {
options(digits=digit)
Eigenvalue <- x$eigen
Component <- 1:length(Eigenvalue)
SingularValue <- sqrt(Eigenvalue)
CumulativeEigenvalue <- cumsum(Eigenvalue)
Inertia <- Eigenvalue/sum(Eigenvalue) * 100
CumulativeInertia <-cumsum(Inertia)
ev <- t(data.frame(Component, SingularValue, Eigenvalue,
CumulativeEigenvalue,Inertia,CumulativeInertia))
print(ev)
invisible(x)
}
#' @title contribution method
#' @description Summarizes contribution of an observation to a dimension
#' @param x an R object
#' @param obs which observation to analyze
#' @param comp which component to analyze
#' @export
ctr.obs <- function(x) UseMethod("ctr.obs")
#' @export
ctr.obs.mfa <- function(x,obs=NULL,comp=NULL,  ...) {
t <- x$cfs^2/nrow(x$cfs)
ctr <- sweep(t,2,colSums(t),'/')
if (is.null(obs) & is.null(comp)){
return(ctr)
} else if (!is.null(obs) & is.null(comp) ){
return(ctr[obs,])
} else if (is.null(obs) & !is.null(comp) ){
return(ctr[,comp])
}
else{
return(ctr[obs,comp])
}
}
#' @title contribution method
#' @description Summarizes contribution of a variable to a dimension
#' @param x an R object
#' @param var which variable to analyze
#' @param comp which component to analyze
#' @export
ctr.var <- function(x) UseMethod("ctr.var")
#' @export
ctr.var.mfa <- function(x, var=NULL,comp=NULL,  ...) {
t <- x$fl^2
ctr <- sweep(t,1,x$weights,'*')
if (is.null(var) & is.null(comp)){
return(ctr)
} else if(!is.null(var) & is.null(comp) ){
return(ctr[var,])
}
else if(is.null(var) & !is.null(comp)){
return(ctr[,comp])
}
else{
return(ctr[var,comp])
}
}
#' @title contribution method
#' @description Summarizes contribution of a table/block to a dimension
#' @param x an R object
#' @param var which table/block to analyze
#' @param comp which component to analyze
#' @export
ctr.table <- function(x) UseMethod("ctr.table")
#' @export
ctr.table.mfa <- function(x, table = NULL,comp=NULL,...) {
t <- ctr.var(x)
idx <- x$index_lists
ctr.slt <- split(data.frame(t),idx)
ctr.table <- list()
for (i in 1:length(ctr.slt)){
ctr.table[[i]]  <- apply(ctr.slt[[i]], 2,sum)}
if (is.null(table) & is.null(comp)){
return(ctr.table)
} else if(!is.null(table) & is.null(comp) ){
return(ctr[[table]])
}
else if(!is.null(table) & !is.null(comp)){
return(ctr.table[[table]][comp])
}
}
ev.summary.mfa(a)
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
plot(mfa1)
plot(a)
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
plot.mfa(a)
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
ev.summary.mfa(a)
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
ev.summary.mfa(a)
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
runApp('~/Dropbox/BERKELEY_study/2016_Fall/02_STAT243/243_proj/Stats-243/final/shiny')
